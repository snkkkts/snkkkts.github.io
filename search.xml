<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>建站目的</title>
    <url>/posts/5048c436.html</url>
    <content><![CDATA[<h1 id="hello-world">Hello World</h1>
<p>你好，这里是snkkkts，你也可以叫我snk（雾</p>
<p>总之，这里是我的个人博客。在接下来的的几年里，我会在这里更新很多的内容，从数据结构与算法的学习笔记，到数学分析、线性代数等数学内容，再到经典好书的摘抄和读书心得，再到平时的随笔等等都会在这个博客上更新。</p>
<p>如果你也有一些想法想要分享，那么欢迎评论哦~</p>
]]></content>
  </entry>
  <entry>
    <title>基础数据结构：栈和队列</title>
    <url>/posts/7dce15fa.html</url>
    <content><![CDATA[<h1 id="栈队列和双端队列">栈、队列和双端队列</h1>
<h2 id="栈">1. 栈</h2>
<p>  <strong>定义：</strong> <strong>堆栈</strong>（stack）又称为<strong>栈</strong>
或
<strong>堆叠</strong>，是计算机科学中的一种抽象资料类型，只允许在有序的线性资料集合的一端（称为堆栈顶端，top）进行加入数据（push）和移除数据（pop）的运算。因而按照后进先出（LIFO,
Last In First
Out）的原理运作，堆栈常用一维数组或链接串列来实现。常与另一种有序的线性资料集合队列相提并论。用户可以在任何时刻向栈中插入一个对象，但只能取得或者删除最后一个插入的对象（即栈顶）。下面是一个使用到堆栈的实例。</p>
<span id="more"></span>
<blockquote>
<p><strong>例1-1：</strong> 文本编辑器通常提供一个“撤销“机制以取消最近的编辑操作并返回到先前的文本状态。这个撤销操作就是通过将文本的变化状态保存在一个栈中得以实现的。</p>
</blockquote>
<h3 id="栈的抽象数据类型">1.1 栈的抽象数据类型</h3>
<p>  栈是最简单也最重要的数据结构，它被广泛地应用到一系列不同的应用中，并在许多更加复杂的数据结构和算法中充当工具。从形式上来说，栈是支持以下两种操作的抽象数据类型（<strong>ADT</strong>），用<strong>S</strong>来表示这一<strong>ADT</strong>实例：</p>
<ul>
<li><strong>S.push(e):</strong> 将一个元素<strong>e</strong>添加到栈<strong>S</strong>的栈顶。</li>
<li><strong>S.pop(e):</strong> 从栈<strong>S</strong>中移除并返回栈顶的元素，如果此时栈是空的，这个操作将出错。此外，为了方便，我们定义了以下访问方法：</li>
<li><strong>S.top():</strong> 在不移除栈顶元素的情况下，返回一个栈<strong>S</strong>的栈顶元素；若栈为空，这个操作将出错。</li>
<li><strong>S.is_empty():</strong> 如果栈中不包含任何元素，则返回一个布尔值 <strong>“True”</strong></li>
<li><strong>len(S):</strong> 返回栈<strong>S</strong>中元素的数量；在<strong>Python</strong>中，我们用__len__这个特殊方法实现它。
按照惯例，我们假定一个新创建的栈是空的，并且其容量也没有预先的限制。添加进栈的元素可以是任何类型的。</li>
</ul>
<h3 id="简单的基于数组的栈实现">1.2 简单的基于数组的栈实现</h3>
<p>  我们可以简单地通过在<strong>Python</strong>列表中存储一些元素来实现一个栈。list类已支持append方法，用于添加一个元素到列表底部，并且支持pop方法，用于移除列表中最后的元素，所以我们可以很自然地将一个列表的尾部与一个栈的顶部相对应起来。这样我们就简单地实现了一个栈的模拟。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">st = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 append() 向栈顶添加元素</span></span><br><span class="line">st.append(<span class="number">2</span>)</span><br><span class="line">st.append(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># &gt;&gt;&gt; st</span></span><br><span class="line"><span class="comment"># [5, 1, 4, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 pop 取出栈顶元素</span></span><br><span class="line">st.pop()</span><br><span class="line"><span class="comment"># &gt;&gt;&gt; st</span></span><br><span class="line"><span class="comment"># [5, 1, 4, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 clear 清空栈</span></span><br><span class="line">st.clear()</span><br></pre></td></tr></table></figure>
<p>虽然程序员可以直接用一个list类代替一个正式的stack类，但是列表还包括一些不符合这种抽象数据类型的方法（比如：增加或者移除处于列表任何位置的元素）。同时，list类所使用的术语也不能与栈这种抽象数据类型的传统命名方法精确对应，特别是append方法和push方法之间的区别。相反，我们将强调如何使用一个列表实现栈元素的内部存储，并同时提供一个符合堆栈的公共接口。</p>
<table>
<thead>
<tr class="header">
<th>栈方法</th>
<th>用Python列表实现</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>S.push(e)</td>
<td>L.append(e)</td>
</tr>
<tr class="even">
<td>S.pop()</td>
<td>L.pop()</td>
</tr>
<tr class="odd">
<td>S.top()</td>
<td>L[-1]</td>
</tr>
<tr class="even">
<td>S.is_empty()</td>
<td>len(L) == 0</td>
</tr>
<tr class="odd">
<td>len(S)</td>
<td>len(L)</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>用Python列表作为存储实现一个栈</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.data = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.data)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.data) == <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,e</span>):</span><br><span class="line">        self.data.append(e)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Empty(<span class="string">&#x27;Stack is empty&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.data[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">             <span class="keyword">raise</span> Empty(<span class="string">&#x27;Stack is empty&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.data.pop()</span><br></pre></td></tr></table></figure>
<h3 id="基于栈的一些应用">1.3 基于栈的一些应用</h3>
<blockquote>
<p>例1-2 LeetCode 20. 有效的括号（Easy）</p>
</blockquote>
<p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s
，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol type="1">
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入</strong>：s = "()"</p>
<p><strong>输出</strong>：true</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong>s = "()<span></span>"</p>
<p><strong>输出：</strong>true</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p><strong>输入：</strong>s = "(]"</p>
<p><strong>输出：</strong>false</p>
</blockquote>
<p>  <strong>思路一：</strong></p>
<p>自左到右，我们可以逐一判断该字符串内的每个括号，如果是左括号，那么我们就将它压入一个栈中，如果是右括号，那么我们就判断这个右括号和栈顶的左括号是否匹配，如果是，就弹出栈顶括号，如果不是，就返回false。</p>
<p>记住，我们的栈是一个只储存左括号的栈，原因是右括号如果入栈，那么它将再也弹不出去</p>
<p>最后，如果这个字符串是有效的，那么我们就得到了一个空栈，反之则无效。</p>
<p>  <strong>代码实现：</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        match_dic = &#123;<span class="string">&#x27;)&#x27;</span>:<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;]&#x27;</span>:<span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>:<span class="string">&#x27;&#123;&#x27;</span>&#125;</span><br><span class="line">        temp_list = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> <span class="string">&#x27;([&#123;&#x27;</span>:</span><br><span class="line">                temp_list.append(ch)</span><br><span class="line">            <span class="keyword">elif</span> ch <span class="keyword">in</span> <span class="string">&#x27;)]&#125;&#x27;</span>:</span><br><span class="line">                <span class="comment"># 右括号比左括号先出现, 不能闭合</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> temp_list:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 遇到右括号, 必然要与上一个左括号闭合, 如果不匹配就 False</span></span><br><span class="line">                <span class="keyword">if</span> match_dic[ch] == temp_list[-<span class="number">1</span>]:</span><br><span class="line">                    temp_list.pop(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 正常闭合的情况下, 栈里面应该全都弹出去了, 所以应该是空的</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> temp_list:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<p>  <strong>思路二：</strong></p>
<p>如果一个字符串是有效的括号，那么它就会在中间出现一个'[]' 或 '{}' 或
'()'结构，当我们删去这些结构后，余下的仍然是一个有效括号。因此，我们可以对一个有效的括号不断进行该操作，直到字符串变空。</p>
<p>  <strong>代码实现：</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="string">&#x27;&#123;&#125;&#x27;</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">&#x27;()&#x27;</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">&#x27;[]&#x27;</span> <span class="keyword">in</span> s:</span><br><span class="line">            s = s.replace(<span class="string">&#x27;&#123;&#125;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            s = s.replace(<span class="string">&#x27;[]&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            s = s.replace(<span class="string">&#x27;()&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> s == <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>例1-3 LeetCode 402. 移掉K位数字（Medium）</p>
</blockquote>
<p>给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k
位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p>
<p><strong>示例 1 ：</strong></p>
<blockquote>
<p><strong>输入：</strong> num = "1432219", k = 3</p>
<p><strong>输出：</strong>"1219"</p>
<p><strong>解释：</strong> 移除掉三个数字 4, 3, 和 2
形成一个新的最小的数字 1219 。</p>
</blockquote>
<p><strong>示例 2 ：</strong></p>
<blockquote>
<p><strong>输入：</strong> num = "10200", k = 1</p>
<p><strong>输出：</strong>"200"</p>
<p><strong>解释：</strong> 移掉首位的 1 剩下的数字为 200.
注意输出不能有任何前导零。</p>
</blockquote>
<p><strong>示例 3 ：</strong></p>
<blockquote>
<p><strong>输入：</strong> num = "10", k = 2</p>
<p><strong>输出：</strong>"0"</p>
<p><strong>解释：</strong> 从原数字移除所有的数字，剩余为空就是 0 。</p>
</blockquote>
<p>  <strong>思路：</strong>
我们知道，对于两个数1234a6和1234b6，如果a大于b，那么前者就大于后者，反之则小于。也就是说，在两个位数相同的数中，相同位第一个不同的数字大小决定了两个数的大小，那么我们就可以有如下想法：维护单调递增栈。</p>
<p>具体实现过程如下：</p>
<p>我们从头扫字符串的每位数字，如果一个数字比栈顶的数字大，那么它就应该入栈，反之，则弹出栈顶数字，再压入该数。弹出k次后停止，此时即为所求。如果没有经过k次就停止了，我们取前n-k位作为我们的答案，因为我们得到了单调递增栈，后面的数不会比前面的更小。</p>
<p>  <strong>代码实现：</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeKdigits</span>(<span class="params">self, num: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> num:</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> c &lt; stk[-<span class="number">1</span>] <span class="keyword">and</span> k:</span><br><span class="line">                stk.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stk.append(c)</span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span>.join(stk)[:<span class="built_in">len</span>(stk) - k].lstrip(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line"><span class="comment"># 注：字符串的.lstrip方法可以用来去除字符串左侧的指定字符和特定序列。</span></span><br><span class="line"><span class="comment"># 与之类似的，rstrip方法可以去除右侧的，strip方法可以去除两侧的。</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>例1-3 LeetCode 321. 拼接最大数 （Hard）</p>
</blockquote>
<p>给定长度分别为 m 和 n 的两个数组，其元素由 0-9
构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k &lt;= m +
n)
个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。</p>
<p>求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。</p>
<p>说明: 请尽可能地优化你算法的时间和空间复杂度。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p><strong>输入:</strong></p>
<p>nums1 = [3, 4, 6, 5]</p>
<p>nums2 = [9, 1, 2, 5, 8, 3]</p>
<p>k = 5</p>
<p><strong>输出:</strong></p>
<p>[9, 8, 6, 5, 3]</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p><strong>输入:</strong></p>
<p>nums1 = [6, 7]</p>
<p>nums2 = [6, 0, 4]</p>
<p>k = 5</p>
<p><strong>输出:</strong></p>
<p>[6, 7, 6, 0, 4]</p>
</blockquote>
<p><strong>示例 3:</strong></p>
<blockquote>
<p><strong>输入:</strong></p>
<p>nums1 = [3, 9]</p>
<p>nums2 = [8, 9]</p>
<p>k = 3</p>
<p><strong>输出:</strong></p>
<p>[9, 8, 9]</p>
</blockquote>
<p>  <strong>思路：</strong></p>
<p>pass</p>
<p>  <strong>代码实现：</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<h2 id="队列">2. 队列</h2>
<p>  <strong>队列</strong>（queue）是另一种基本的数据结构，它与栈互为“表亲”关系，队列是由一系列对象组成的集合，这些对象的插入和删除遵循先进先出（First
in First out,
FIFO)的原则。也就是说，元素可以在任何时刻进行插入，但是只有处在队列最前面的元素才能被删除。</p>
<p>  我们通常将队列中允许插入的一段称为队尾（rear），将允许删除的一段称为队头（front）。对这个属于的一个形象比喻就是一堆人在排队进入游乐场。人们从队尾插入排队等待进入游乐场，而从这个队的队头进入游乐场。</p>
<h3 id="队列的抽象数据类型">2.1 队列的抽象数据类型</h3>
<p>  通常来说，队列的抽象数据类型定义了一个包含一系列对象的集合，其中元素的访问和删除被限制在队列的第一个元素，而且元素的插入被限制在序列的尾部。这个限制根据FIFO原则执行元素的插入和删除操作。对于队列Q而言，队列的抽象数据类型支持如下两个基本方法：</p>
<ul>
<li><strong>Q.enqueue(e):</strong>
向队列<strong>Q</strong>的队尾添加一个元素。</li>
<li><strong>Q.dequeue():</strong>
从队列<strong>Q</strong>中移除并返回第一个元素，如果队列为空，则触发一个错误。</li>
</ul>
<p>队列的抽象数据类型还包括如下方法（第一个类似堆栈的top方法）：</p>
<ul>
<li><strong>Q.first():</strong>
在不移除的前提下返回队列的第一个元素；如果队列为空，则触发一个错误。</li>
<li><strong>Q.is_empty():</strong>
如果队列<strong>Q</strong>没有包含任何元素则返回布尔值“<strong>True</strong>”。</li>
<li><strong>len(Q):</strong>
返回队列<strong>Q</strong>中元素的数量；在<strong>Python</strong>中我们通过__len__这个特殊方法实现。</li>
</ul>
<h3 id="基于数组的队列实现">2.2 基于数组的队列实现</h3>
<p>  对于栈这种抽象数据结构类型，我们用Python列表作为底层存储创造了一个非常简单的适配器类，也可以使用类似的方法支持一个队列的抽象数据类型。我们可以用append(e)方法将e添加至列表的尾部。当一个元素退出队列后，我们可以使用pop(0)来移除列表中的第一个元素。</p>
<p>  这是非常简单的实现方式，因此它也最为低效。我们知道，当pop操作在一个列表中以非索引的方式调用时，可以通过执行一个循环将所有在特定索引另一边的元素转移到它的左边，目的是为了填补由pop操作给序列造成的“洞”。因此，一个pop(0)操作的调用总是处于最坏的情况，耗时为O(n)</p>
<p>  我们可以改进上面的策略，完全避免调用pop(0)。可以用一个指代为空的指针代替这个数组中离队的元素，并且保留一个显式的变量f来存储当前在最前面的元素的索引。这样一个算法对于离队操作而言耗时为O(1)。然而这种方法仍有一个缺点：如果我们允许队列的前端远离索引0，那么随着不断地删除添加操作，底层数组的大小将逐渐增长到O(m)，其中m值等于自队列创建以来对队列进行追加元素操作的总和，而不是当前队列中元素的数量。这种设计会在一些所需队列的大小相对稳定却被长时间使用的程序中产生不利的影响。</p>
<p>  <strong>循环使用数组</strong></p>
<p>  为了开发一种更为健壮的队列实现方法，我们让队列的前端不断趋向数组的右端，同时让队列内的元素在底层数组尾部“循环”。我们假定底层数组的长度为固定值N，它比实际队列中元素的数量大。新的元素在当前队列的尾部利用入队操作进入队列，逐步将元素从队列的前面插入到索引为N-1的位置，然后紧接着时索引为0的位置，接着是索引为1的位置，下表所示为一个第一个元素为E最后一个元素为M的队列，可用于说明这一过程。</p>
<table>
<thead>
<tr class="header">
<th>I</th>
<th>J</th>
<th>K</th>
<th>L</th>
<th>M</th>
<th>...</th>
<th>E</th>
<th>F</th>
<th>G</th>
<th>H</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td>f</td>
<td></td>
<td></td>
<td>N-1</td>
</tr>
</tbody>
</table>
<p>  实现这种循环的方法并不困难。当从队列中删除一个元素并欲更新前面的索引时，我们可以使用算式f=(f+1)%N进行计算。例如：有一个长度为10的列表，有一个索引为7的首部，我们可以计算(7+1)%10
== 8来更新首部。</p>
<p>  <strong>Python队列的实现方法</strong></p>
<p>  在接下来的代码段中，我们给出了通过使用Python列表以循环的方式来实现一个队列的抽象数据类型的完整方法。其中，这个队列类维护如下3个实例变量:</p>
<ul>
<li>_data:指一个固定容量的列表实例。</li>
<li>_size:是一个整数，代表当前存储在队列内的元素的数量。</li>
<li>_front:是一个整数，代表_data实例队列中的第一个索引。它被初始化为0.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span>:</span><br><span class="line">    DEFAULT_CAPACITY = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._data = [<span class="literal">None</span>] * ArrayQueue.DEFAULT_CAPACITY</span><br><span class="line">        self._size = <span class="number">0</span></span><br><span class="line">        self._front = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._size == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">first</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Empty(<span class="string">&#x27;Queue is empty&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._data[self._front]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Empty(<span class="string">&#x27;Queue is empty&#x27;</span>)</span><br><span class="line">        answer = self._size[self._front] </span><br><span class="line">        self._data[self.front] = <span class="literal">None</span></span><br><span class="line">        self._front = (self._front + <span class="number">1</span>) % <span class="built_in">len</span>(self._data)</span><br><span class="line">        self._size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> answer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self,e</span>):</span><br><span class="line">        <span class="keyword">if</span> self._size == <span class="built_in">len</span>(self._data):</span><br><span class="line">            self._resize(<span class="number">2</span> * <span class="built_in">len</span>(self._data))</span><br><span class="line">        avail = (self._front + self._size) % <span class="built_in">len</span>(self._data)</span><br><span class="line">        self._data[avail] = e</span><br><span class="line">        self._size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_resize</span>(<span class="params">self,cap</span>):</span><br><span class="line">        old = self._data</span><br><span class="line">        self._data = [<span class="literal">None</span>] * cap</span><br><span class="line">        walk = self._front</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self._size):</span><br><span class="line">            self._data[k] = old[walk]</span><br><span class="line">            walk = (<span class="number">1</span> + walk) % <span class="built_in">len</span>(old)</span><br><span class="line">        self._front = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>
在上述的实现过程中我们发现，当在队列满的状态下调用enqueue操作时，底层的存储数组就要进行扩展，但是调用dequeue操作时却并不会进行缩减数组的大小的处理。这样处理的结果是，底层的存储数组的大小是队列曾存储的最多元素的个数，而不是当前元素的个数。</p>
<p>  无论什么时候，当所存储的元素降低导数组总存储能力的1/4时，一个健壮的方法是将这个数组大小缩减到当前容量的一半。这一处理可以通过在dequeue发那个发中插入如下两行代码来实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">0</span> &lt; self._size &lt; <span class="built_in">len</span>(self._data) // <span class="number">4</span>:</span><br><span class="line">    self._resize(<span class="built_in">len</span>(self._data) // <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="双端队列">2.3 双端队列</h3>
<p>  接下来考虑一个类队列数据结构，它支持在队列的头部和尾部都进行插入和删除操作，这样一种结构被称为<strong>双端队列</strong>（double-ended
queue 或者 deque）。</p>
<p>  双端队列的抽象数据类型比栈和队列的抽象数据类型要更普遍。在一些应用中，这些额外的普遍性是非常有用的，例如使用一个队列来描述餐馆当中的等餐队列。</p>
<p>  <strong>使用环形数组实现双端队列</strong></p>
<p>  我们可以使用上述代码段提供的ArrayQueue类相同的方法来实现队列的抽象数据类型。这个ADT应该支持如下方法：</p>
<ul>
<li><strong>D.add_first(e):</strong>
向双端队列的前面添加一个元素<strong>e</strong>。</li>
<li><strong>D.add_last(e):</strong>
向双端队列的后面添加一个元素<strong>e</strong>。</li>
<li><strong>D.delete_first():</strong>
从双端队列中移除并返回第一个元素。若双端队列为空，则触发一个错误。</li>
<li><strong>D.delete_last():</strong>
从双端队列中移除并返回最后一个元素。若双端队列为空，则触发一个错误。</li>
</ul>
<p>  此外，双端队列的抽象数据类型还包括如下的方法：</p>
<ul>
<li><strong>D.first():</strong>
返回（但不移除）双端队列的第一个元素。若双端队列为空，则触发一个错误。</li>
<li><strong>D.last():</strong>
返回（但不移除）双端队列的最后一个元素。若双端队列为空，则触发一个错误。</li>
<li><strong>D.is_empty():</strong>
如果双端队列不包括任何一个元素，则返回布尔值“True”。</li>
<li><strong>len(D):</strong>
返回当前双端队列中的元素个数。在Python中，我们用__len__这个特殊方法实现它。</li>
</ul>
<p>  我们不在此赘述具体的代码实现方式，无论什么时候，只要想直到双端队列的尾部索引，或者超过队尾的第一个可用的位置，我们就可以通过<strong>模运算</strong>计算得出。例如，方法last()就是用如下索引公式来实现的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">back = (self._front + self._size - <span class="number">1</span>) % <span class="built_in">len</span>(self._data)</span><br></pre></td></tr></table></figure>
<p>  <strong>Python collections模块中的双端队列</strong></p>
<p>  Python的标准collections模块中包含对一个双端队列类的实现方法，它是位于collections模块中的deque类，我们可以通过from
collections import
deque来访问它。下表给出了我们构造的双端队列与deque类的比较。</p>
<table>
<thead>
<tr class="header">
<th>我们的双端队列ADT</th>
<th>collections.deque</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>len(D)</td>
<td>len(D)</td>
<td>元素数量</td>
</tr>
<tr class="even">
<td>D.add_first()</td>
<td>D.appendleft()</td>
<td>加到开头</td>
</tr>
<tr class="odd">
<td>D.add_last()</td>
<td>D.append()</td>
<td>加到结尾</td>
</tr>
<tr class="even">
<td>D.delete_first()</td>
<td>D.popleft()</td>
<td>从开头移除</td>
</tr>
<tr class="odd">
<td>D.delete_last()</td>
<td>D.pop()</td>
<td>从结尾移除</td>
</tr>
<tr class="even">
<td>D.first()</td>
<td>D[0]</td>
<td>访问第一个元素</td>
</tr>
<tr class="odd">
<td>D.last()</td>
<td>D[-1]</td>
<td>访问最后一个元素</td>
</tr>
<tr class="even">
<td></td>
<td>D[j]</td>
<td>通过索引访问任意一项</td>
</tr>
<tr class="odd">
<td></td>
<td>D[j] = val</td>
<td>通过索引修改任意一项</td>
</tr>
<tr class="even">
<td></td>
<td>D.clear()</td>
<td>清除所有内容</td>
</tr>
<tr class="odd">
<td></td>
<td>D.rotate(k)</td>
<td>循环右移k步</td>
</tr>
<tr class="even">
<td></td>
<td>D.remove(e)</td>
<td>移除第一个匹配的元素</td>
</tr>
<tr class="odd">
<td></td>
<td>D.count(e)</td>
<td>统计对于e匹配的数量</td>
</tr>
</tbody>
</table>
<p><strong>注1：</strong>
rotate方法被描述为“循环右移k步”，它相当于对数组中每个元素整体右移k个长度，到达数组尾部后循环到开头。</p>
<p><strong>注2：</strong>
库函数队列的构造函数同样支持一个可选的maxlen参数以建立一个固定长度的双端队列（deque(maxlen=10)）。然而，当双端队列满时，如果在队列的任意一端调用append方法，它并不会触发一个错误；相反，这会导致在相反一段移除一个元素。也就是说，当队列满时，调用appendleft方法会导致右端一个隐藏的pop调用发生，以便为新加入的元素腾出空间。下面给出了一些简单的实例。
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包含一些元素的 deque</span></span><br><span class="line">my_deque = deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在指定位置插入元素</span></span><br><span class="line">my_deque.insert(<span class="number">2</span>, <span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除指定值的第一个匹配项</span></span><br><span class="line">my_deque.remove(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回指定值的第一个匹配项的索引</span></span><br><span class="line">index = my_deque.index(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回指定值的出现次数</span></span><br><span class="line">count = my_deque.count(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反转 deque 中的元素</span></span><br><span class="line">my_deque.reverse()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(my_deque)   <span class="comment"># 输出: deque([5, 4, 99, 3, 1])</span></span><br><span class="line"><span class="built_in">print</span>(index)      <span class="comment"># 输出: 1</span></span><br><span class="line"><span class="built_in">print</span>(count)      <span class="comment"># 输出: 0（因为 2 已被移除）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rotate的应用</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包含一些元素的 deque</span></span><br><span class="line">my_deque = deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向右循环移动两步</span></span><br><span class="line">my_deque.rotate(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(my_deque)  <span class="comment"># 输出: deque([4, 5, 1, 2, 3])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向左循环移动一步</span></span><br><span class="line">my_deque.rotate(-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(my_deque)  <span class="comment"># 输出: deque([5, 1, 2, 3, 4])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># maxlen的应用</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个最大长度为 3 的 deque</span></span><br><span class="line">my_deque = deque(maxlen=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向 deque 中添加元素</span></span><br><span class="line">my_deque.append(<span class="number">1</span>)</span><br><span class="line">my_deque.append(<span class="number">2</span>)</span><br><span class="line">my_deque.append(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_deque)  <span class="comment"># 输出: deque([1, 2, 3])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 超过最大长度，会自动删除左侧元素</span></span><br><span class="line">my_deque.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(my_deque)  <span class="comment"># 输出: deque([2, 3, 4])</span></span><br></pre></td></tr></table></figure></p>
<p>  <strong>双栈模拟队列</strong></p>
<p>  还有一种冷门的方法是使用两个 栈 来模拟一个队列。</p>
<p>  这种方法使用两个栈 F, S 模拟一个队列，其中 F 是队尾的栈，S
代表队首的栈，支持 push（在队尾插入），pop（在队首弹出）操作：</p>
<p>  push：插入到栈 F 中。</p>
<p>  pop：如果 S 非空，让 S 弹栈；否则把 F 的元素倒过来压到 S
中（其实就是一个一个弹出插入，做完后是首尾颠倒的），然后再让 S
弹栈。</p>
<p>  容易证明，每个元素只会进入/转移/弹出一次，均摊复杂度 O(1)。</p>
]]></content>
      <categories>
        <category>基础数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构：链表</title>
    <url>/posts/6b848df6.html</url>
    <content><![CDATA[<h1 id="链表">链表</h1>
<p>  在本章中，我们将介绍一种名为<strong>链表</strong>的数据结构，它为基于数组的序列提供了另一种选择。基于数组的序列和链表都能够对其中的元素保持一定的顺序，但采用的方式截然不同。数组提供更加集中的表示法，一个大的内存块能够为许多元素提供存储和引用。相对的，一个链表依赖于更多的分布式表示方法，采用称作<strong>节点</strong>的轻量级对象，分配给每一个元素。每个节点维护一个指向它的元素的引用，并含一个或多个指向相邻节点的引用，这样做的目的是为了集中地表示序列的线性顺序。</p>
<span id="more"></span>
<p>  内存空间是所有程序的公共资源，在一个复杂的系统运行环境下，空闲的内存空间可能散落在内存各处。我们知道，存储数组的内存空间必须是连续的，而当数组非常大时，内存可能无法提供如此大的连续空间。此时链表的灵活性优势就体现出来了。链表的设计使得各个节点可以分散存储在内存各处，它们的内存地址无须连续。</p>
<blockquote>
<p>链表的定义类</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;链表节点类&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val:<span class="built_in">int</span></span>):</span><br><span class="line">        self.val: <span class="built_in">int</span> = val    <span class="comment"># 节点值     </span></span><br><span class="line">        self.<span class="built_in">next</span>: ListNode | <span class="literal">None</span> = <span class="literal">None</span>    <span class="comment"># 指向下一节点的引用</span></span><br></pre></td></tr></table></figure>
<h2 id="单向链表">1.单向链表</h2>
<p>  链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向链表中的下一个节点，而最后一个节点则指向一个空值。因此在相同数据量下，链表比数组占用更多的内存空间。</p>
<blockquote>
<p>一个简单的单向链表的流程图</p>
</blockquote>
<p><img
src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_definition.png" /></p>
<p>  <strong>初始化链表</strong></p>
<p>  建立链表分为两步，第一步是初始化各个节点对象，第二步是构建节点之间的引用关系。初始化完成后，我们就可以从链表的头节点触发，通过引用指向<code>next</code>一次访问所有节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化链表 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4</span></span><br><span class="line"><span class="comment"># 初始化各个节点</span></span><br><span class="line">n0 = ListNode(<span class="number">1</span>)</span><br><span class="line">n1 = ListNode(<span class="number">3</span>)</span><br><span class="line">n2 = ListNode(<span class="number">2</span>)</span><br><span class="line">n3 = ListNode(<span class="number">5</span>)</span><br><span class="line">n4 = ListNode(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 构建节点之间的引用</span></span><br><span class="line">n0.<span class="built_in">next</span> = n1</span><br><span class="line">n1.<span class="built_in">next</span> = n2</span><br><span class="line">n2.<span class="built_in">next</span> = n3</span><br><span class="line">n3.<span class="built_in">next</span> = n4</span><br></pre></td></tr></table></figure>
<p>  我们通常将头节点当作链表的代称，比如以上代码中的链表可记作链表<code>n0</code></p>
<p>  <strong>插入节点</strong></p>
<p>  在链表中插入节点非常容易，如下图所示，假设我们想在相邻的两个节点<code>n0</code>和<code>n1</code>之间插入一个新节点<code>p</code>，则只需改变两个节点引用（指针）即可，时间复杂度为<span
class="math inline">\(O(1)\)</span>。相比之下，数组中插入元素的时间复杂度为<span
class="math inline">\(O(n)\)</span>，在大数据量下的效率较低。</p>
<blockquote>
<p>链表插入节点示例</p>
</blockquote>
<p><img
src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_insert_node.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">n0: ListNode, P: ListNode</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;在链表的节点 n0 之后插入节点 P&quot;&quot;&quot;</span></span><br><span class="line">    n1 = n0.<span class="built_in">next</span></span><br><span class="line">    P.<span class="built_in">next</span> = n1</span><br><span class="line">    n0.<span class="built_in">next</span> = P</span><br></pre></td></tr></table></figure>
<p>  <strong>删除节点</strong></p>
<p>  如下图所示，在链表中删除节点也变得非常方便，只需要改变一个节点的引用（指针）即可。</p>
<p>  请注意，尽管在删除操作完成后节点 P 仍然指向 n1
，但实际上遍历此链表已经无法访问到 P ，这意味着 P
已经不再属于该链表了。</p>
<p><img
src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_remove_node.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">n0: ListNode</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;删除链表的节点 n0 之后的首个节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> n0.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># n0 -&gt; P -&gt; n1</span></span><br><span class="line">    P = n0.<span class="built_in">next</span></span><br><span class="line">    n1 = P.<span class="built_in">next</span>    <span class="comment"># 此时构建了n0 -&gt; P -&gt; n1的链表</span></span><br><span class="line">    n0.<span class="built_in">next</span> = n1    <span class="comment"># 此时删除了n0后的节点p</span></span><br></pre></td></tr></table></figure>
<p>  <strong>访问节点</strong></p>
<p>  在链表中访问节点的效率较低。对比数组来说，我们可以在<span
class="math inline">\(O(1)\)</span>时间内访问数组中的任意元素。链表则需要从头节点出发，逐个向后遍历，直至找到目标节点。也就是说，访问链表的第<span
class="math inline">\(i\)</span>个节点需要循环<span
class="math inline">\(i-1\)</span>轮，时间复杂度为<span
class="math inline">\(O(n)\)</span>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">access</span>(<span class="params">head: ListNode, index: <span class="built_in">int</span></span>) -&gt; ListNode | <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;访问链表中索引为 index 的节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<p>  <strong>查找节点</strong></p>
<p>  遍历列表，查找其中值为<code>target</code>的节点，输出该节点在链表中的索引。此过程也属于线性查找。代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">head: ListNode, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;在链表中查找值为 target 的首个节点&quot;&quot;&quot;</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        <span class="keyword">if</span> head.val == target:</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="用单向链表实现栈">1.1 用单向链表实现栈</h3>
<p>  在这一部分，我们将通过给出一个完整栈ADT的Python实现来说明单向链表的使用。设计这样的实现，我们需要决定用链表的头部或尾部来实现栈顶。最好的选择显而易见：因为只有在头部，我们才能在一个常数时间内有效地插入和删除元素。由于所有栈操作都会影响栈顶，因此规定栈顶在链表的头部。</p>
<blockquote>
<p>单向链表实现栈ADT</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># nested _Node class</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">_Node</span>:</span><br><span class="line">        __slots__ = <span class="string">&#x27;_val&#x27;</span>,<span class="string">&#x27;_next&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val,<span class="built_in">next</span></span>):</span><br><span class="line">            self._val = val</span><br><span class="line">            self._<span class="built_in">next</span> =  <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># stack mathods</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line">        self._size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._size == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,e</span>):</span><br><span class="line">        self._head = self._Node(e,self._head)    <span class="comment"># 新的头节点被定义为值为e，指针指向旧的头节点的节点</span></span><br><span class="line">        self._size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Empty(<span class="string">&#x27;Stack is empty&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._head._val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Empty(<span class="string">&#x27;Stack is empty&#x27;</span>)</span><br><span class="line">        answer = self._head._val</span><br><span class="line">        self._head = self._head._<span class="built_in">next</span></span><br><span class="line">        self._size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>
<h2 id="用单向链表实现队列">1.2 用单向链表实现队列</h2>
<p>  正如用单向链表实现栈ADT一样，我们可以用单向链表实现队列ADT，且所有操作支持最坏情况的时间为<span
class="math inline">\(O(1)\)</span>。由于需要对队列的两端执行操作，我们显式地为每个队列维护一个_head和一个_tail指针作为实例变量。一个很自然的做法是，将队列的前段和链表的头部对应，队列的后端与链表的尾部对应，因为必须使元素从队列的尾部进入队列，从队列的头部出队列（我们很难高效地从单向链表的尾部删除元素）。链表队列（LinkQueue）类的实现如以下代码所示。</p>
<blockquote>
<p>用单向链表实现队列ADT</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedQueue</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">_Node</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line">        self._tail = <span class="literal">None</span></span><br><span class="line">        self._size = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._size == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">first</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Empty(<span class="string">&#x27;Queue is empty&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._head._val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Empty(<span class="string">&#x27;Queue is empty&#x27;</span>)</span><br><span class="line">        answer = self._head._val</span><br><span class="line">        self._head = self._head._<span class="built_in">next</span></span><br><span class="line">        self._size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._tail = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self,e</span>):</span><br><span class="line">        newset = self._Node(e,<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = newset</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._tail._<span class="built_in">next</span> = newset</span><br><span class="line">        self._tail = newset</span><br><span class="line">        self._size += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>  用单向链表实现队列的很多方面和用LinkedStack类实现非常相似，如嵌套_Node类的定义。链表队列的LinkedQueue的视线类似于LinkedStack的出栈，即删除队列的头部节点，但也有一些细微的差别。因为队列必须准确的维护尾部的引用（栈的实现中没有维护这样的变量）。通常，在头部的操作对尾部不产生影响。但在一个队列中调用元素出队列操作时，我们要同时删除列表的尾部。同时为了确保一致性，还要设置self._tail为None。</p>
<h2 id="循环链表环形链表">2.循环链表（环形链表）</h2>
<p>  在链表中，我们可以使单向链表尾部节点的“next”指针指向链表的头部，由此来获得一个更切实际的循环链表的概念。在循环链表中，任意节点都可以视作头节点。循环链表也可以实现一个循环队列类，这里不再赘述。</p>
<h2 id="双向链表">3.双向链表</h2>
<p>  在单向链表中，每个节点为其后继节点维护一个引用。我们已经说明了在管理一个序列的元素时如何使用这样的表示方法。然而，单向链表的不对称性产生了一些限制。我们强调过可以有效地想一个单向链表内部的任意位置插入一个节点，也可以在头部轻松删除一个节点，但是不能有效删除链表尾部的节点。更一般化的说法是，如果仅给定链表内部指向任意一个节点的引用，我们很难有效地删除该节点，因为我们无法立即确定待删除节点的前驱节点（而且删除处理中该前驱节点需要更新它的“next”引用）。</p>
<p>  为了更好的对称性，我们定义了一个双向链表。与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。这些列表支持更多各种时间复杂度为<span
class="math inline">\(O(1)\)</span>的更新操作，这些更新操作包括在列表的任意位置插入和删除节点。我们会继续用“next”表示指向当前节点的后继节点的引用，并引入“prev”引用其前驱节点。</p>
<p>  <strong>头哨兵和尾哨兵</strong></p>
<p>  在操作接近一个双向链表的边界时，为了避免一些特殊情况，在链表的两端都追加节点是很有用处的：在列表的起始位置添加头节点（header），在列表的结尾位置添加尾节点（tailer）。这些“特定”的节点被称为哨兵。这些节点中并不存储主序列的元素。特别的，头节点有时会存储链表长度等基本信息。</p>
<p>  当使用哨兵节点时，一个空链表需要初始化，使头节点的“next”域指向尾节点，并令尾节点的“prev”域指向头节点。哨兵节点的其他域是无关紧要的。对于一个非空的链表，头节点的“next”域将指向一个序列中第一个真正包含元素的节点，对应的尾节点的“prev”域指向这个序列中最后一个包含元素的节点。</p>
<p>  <strong>使用哨兵的优点</strong></p>
<p>  虽然不使用哨兵节点就可以实现双向链表，但哨兵只占用很小的额外空间就能极大地简化操作的逻辑。最明显的是，头和尾节点从来不改变————只改变头节点和尾节点之间的节点。此外，可以用统一的方式处理所有插入节点操作，因为一个新节点总是被放在一对已知节点之间。类似地，每个待删除的元素都是确保被存储在前后都有邻居的节点中的。</p>
<blockquote>
<p>双向链表的基本实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;双向链表节点类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val: <span class="built_in">int</span></span>):</span><br><span class="line">        self.val: <span class="built_in">int</span> = val                <span class="comment"># 节点值</span></span><br><span class="line">        self.<span class="built_in">next</span>: ListNode | <span class="literal">None</span> = <span class="literal">None</span>  <span class="comment"># 指向后继节点的引用</span></span><br><span class="line">        self.prev: ListNode | <span class="literal">None</span> = <span class="literal">None</span>  <span class="comment"># 指向前驱节点的引用</span></span><br></pre></td></tr></table></figure>
<p>  下图给出了常见的链表种类</p>
<p><img
src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_common_types.png" /></p>
]]></content>
      <categories>
        <category>基础数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/posts/7b216a3b.html</url>
    <content><![CDATA[<h1 id="树">树</h1>
<p>  作为一种非线性的数据结构，树（tree）表现出与链表、数组等线性结构在组织关系上的差异，这种组织关系比一个序列中两个元素之间简单的“前”和“后”关系更加丰富和复杂。这种关系在树中是分层的（hierarchical），一些元素位于“上层”，而一些元素位于“下层”。树为数据提供了一个更加真实、自然的组织结构，由此实现的一系列算法也比使用线性数据结构要快得多。出于篇幅原因，我们仅在下文中介绍树的一些基本的内容。</p>
<span id="more"></span>
<h2 id="树的定义和属性">树的定义和属性</h2>
<p>  <strong>正式的树的定义</strong></p>
<p>  通常我们将树<em>T</em>定义为存储一系列元素的有限节点集合，这些节点具有parent-children关系并且满足如下属性：</p>
<ul>
<li>如果树<em>T</em>不为空，那它一定具有一个称为根节点的特殊节点，并且该节点没有父节点。</li>
<li>如果每个非根节点<em>v</em>都具有唯一的父节点<em>w</em>，每个具有父节点<em>w</em>的节点都是节点<em>w</em>的一个孩子。</li>
</ul>
<p>  注意，根据以上定义，一棵树可能为空，这意味着它不含有任何节点。这个约定也允许我们递归地定义一棵树，以使这棵树<em>T</em>要么为空，要么包含一个节点<em>r</em>（其称为树<em>T</em>的根节点），其他一系列子树的根节点是<em>r</em>的孩子节点。</p>
<p>  <strong>其他节点关系</strong></p>
<p>  同一个父节点的孩子节点之间是兄弟关系。一个没有孩子的节点<em>v</em>称为外部节点。有一个或多个孩子的节点<em>v</em>称为内部节点。外部节点也称为叶子节点。</p>
<p>  <strong>树的边和路径</strong></p>
<p>  树<em>T</em>的边指的是一对节点（<em>u</em>，<em>v</em>），<em>u</em>是v的父节点或v是u的父节点。树T当中的路径指的是一系列的节点，这些节点中任意两个连续的节点之间都是一条边。</p>
<p>  <strong>有序树</strong></p>
<p>  如果树中每个节点的孩子节点都有特定的顺序，则称该树为有序树。我们将一个节点的子节点依次编号为第一个，第二个，第三个等。通常我们按照从左到右的顺序对兄弟节点进行排序。</p>
<h3 id="树的抽象数据类型">树的抽象数据类型</h3>
<p>  我们用位置作为节点的抽象结构来定义树的抽象数据类型结构。一个元素存储在一个位置，并且位置信息满足树中的父节点和子节点的关系。一棵树的位置对象支持如下方法：</p>
<ul>
<li>p.element():返回存储在位置p中的元素。</li>
</ul>
<p>树的抽象数据类型支持如下访问方法。允许使用者访问一棵树的不同位置：</p>
<ul>
<li>T.root():返回树T的根节点的位置。如果树为空，则返回None。</li>
<li>T.is_root(p):如果位置p是树T的根，则返回True。</li>
<li>T.parent(p):返回位置为p的父节点的位置。如果p的位置为树的根节点，则返回None。</li>
<li>T.num_children(p):返回位置为p的孩子节点的编号。</li>
<li>T.children(p):产生位置为p的孩子节点的一个迭代。</li>
<li>T.is_leaf(p):如果位置节点p没有任何孩子，则返回True。</li>
<li>len(T):返回树T所包含的元素的数量。</li>
<li>T.is_empty():如果树T不包含任何位置，则返回True。</li>
<li>T.positions():迭代地生成树T的所有位置。</li>
<li>iter(T):迭代地生成存储在树T中的所有元素。</li>
</ul>
<p>  以上所有方法都接受一个位置作为参数，但是如果树T中的这个位置是无效的，则调用它就会触发一个VaiueError。我们将在之后的内容通过一棵树的所有位置来讨论迭代生成方法。</p>
<h3 id="计算深度和高度">计算深度和高度</h3>
<p>  假定p是树T中的一个节点，那么p的深度就是节点p的祖先的个数，不包括p本身。这种定义表明树的根节点的深度为0.p的深度同样也可以按如下递归定义：</p>
<ul>
<li>如果p是根节点，那么p的深度为0.</li>
<li>否则，p的深度就是其父节点的深度加1。</li>
</ul>
<p>  就这个定义，我们在下面给出计算树T中一个节点p的深度的简单递归算法。该算法递归地调用自身。</p>
<blockquote>
<p>树类中计算深度的算法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">depth</span>(<span class="params">self,p</span>):</span><br><span class="line">    <span class="keyword">if</span> self.is_root(p):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + self.depth(self.parent(p))</span><br></pre></td></tr></table></figure>
<p>  树T中节点p的高度的定义如下：</p>
<ul>
<li>如果p是一个叶子节点，那么它的高度为0。</li>
<li>否则，p的高度是它孩子节点中的最大高度加1。</li>
</ul>
<p>  一颗非空树T的高度是树根节点的高度。除此之外，一颗非空树T的高度也等于其所有叶子节点深度的最大值。</p>
<blockquote>
<p>计算高度的方法_height1</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_height1</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(self.depth(p) <span class="keyword">for</span> p <span class="keyword">in</span> self.positions() <span class="keyword">if</span> self.is_leaf(p))</span><br></pre></td></tr></table></figure>
<p>  不幸的是，这个算法并不搞笑，在最坏的情况下，它的执行时间为<span
class="math inline">\(O(n)\)</span>。</p>
<p>  不依赖先前的递归定义，我们可以更加高效地计算树的高度，使其执行时间为<span
class="math inline">\(O(n)\)</span>。为了这样做，我们将给予一棵树中的某个位置参数化一个函数，并计算以这个节点作为根节点的子树的高度。下面的代码段给出了示例。</p>
<blockquote>
<p>计算一个以p节点为根节点的子树的高度</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_height2</span>(<span class="params">self,p</span>):</span><br><span class="line">    <span class="keyword">if</span> self.is_leaf(p):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(self._height2(c) <span class="keyword">for</span> c <span class="keyword">in</span> self.children(p))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>计算整个树或者一个给定位置作为根节点的子树的高度的Tree.height方法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">slef,p=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        p = self.root()</span><br><span class="line">    <span class="keyword">return</span> self._height2(p)</span><br></pre></td></tr></table></figure>
<h2 id="二叉树">二叉树</h2>
<p>  二叉树是具有以下属性的有序树：</p>
<ol type="1">
<li>每个节点最多有两个子节点。</li>
<li>每个子节点被命名为左子节点或右子节点。</li>
<li>对于每个节点的子节点，在顺序上，左先于右。</li>
</ol>
<p>  <strong>一些术语</strong></p>
<ul>
<li>「根节点 root node」：位于二叉树顶层的节点，没有父节点。</li>
<li>「叶节点 leaf node」：没有子节点的节点，其两个指针均指向 None
。</li>
<li>「边 edge」：连接两个节点的线段，即节点引用（指针）。</li>
<li>节点所在的「层 level」：从顶至底递增，根节点所在层为 1 。</li>
<li>节点的「度 degree」：节点的子节点的数量。在二叉树中，度的取值范围是
0、1、2 。</li>
<li>二叉树的「高度 height」：从根节点到最远叶节点所经过的边的数量。</li>
<li>节点的「深度 depth」：从根节点到该节点所经过的边的数量。</li>
<li>节点的「高度
height」：从距离该节点最远的叶节点到该节点所经过的边的数量。</li>
</ul>
<p><img
src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_terminology.png" /></p>
<h3 id="二叉树的类型">二叉树的类型</h3>
<p>  <strong>满二叉树</strong>（full binary
tree）是一种二叉树，其中每个节点都具有0或2个子节点。定义满二叉树的另一种方法是递归定义。满二叉树是：</p>
<ul>
<li>单个顶点（单个节点作为根节点）</li>
<li>根节点有两个子树，并且两个子树都是满二叉树的树</li>
</ul>
<p><img
src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/full_binary_tree.png" /></p>
<p>  <strong>完美二叉树</strong>（perfect binary
tree）是一种二叉树,其中所有的内部节点都有两个子节点，并且所有的叶节点都具有相同的深度或相同的层级。完美二叉树是满二叉树。</p>
<p><img
src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/perfect_binary_tree.png" /></p>
<p>  <strong>完全二叉树</strong>（complete binary
tree）是这样的二叉树：除了最后一层外，每一层都被完全填满，并且最后一层的所有节点都尽可能远离左边。因此，完美的树总是完全的，但完全的树并不总是完美的。使用数组可以有效地表示完全二叉树。</p>
<p><img
src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/complete_binary_tree.png" /></p>
<p>  <strong>平衡二叉树</strong>（balanced binary
tree）是一种二叉树结构，其中每个节点的左子树和右子树的高度相差不超过1（或倾斜不大于1）。你也可以考虑它是这样的树，其中没有叶子比其他任何叶子距离根更远（对“更远”有不同的定义）。</p>
<p><img
src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/balanced_binary_tree.png" /></p>
<p>  <strong>退化（病态）二叉树</strong>（degenerate or pathological
tree）是指每个父节点只有一个关联的子节点，这意味着它本质上退化成了链表，丧失了几乎全部使用二叉树的优势。而另一种极端情况则是完美二叉树，它可以充分发挥出二叉树“分治”的优势。</p>
<p><img
src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_best_worst_cases.png" /></p>
<h3 id="二叉树的属性">二叉树的属性</h3>
<p>  二叉树节点与高度之间存在如下关系：</p>
<p>  设<span class="math inline">\(T\)</span>为非空二叉树,<span
class="math inline">\(n、n_E、n_I\)</span>和<span
class="math inline">\(h\)</span>分别表示<span
class="math inline">\(T\)</span>的节点数、外部节点数、内部节点数和高度，则<span
class="math inline">\(T\)</span>具有如下属性：</p>
<ol type="1">
<li><span class="math inline">\(h+1\le n\le 2^{h+1}-1\)</span></li>
<li><span class="math inline">\(1\le n_E\le 2^h\)</span></li>
<li><span class="math inline">\(h\le n_I\le 2^h-1\)</span></li>
<li><span class="math inline">\(\log(n+1)-1\le h\le
\frac{(n-1)}{2}\)</span></li>
</ol>
<p>  另外，若<span class="math inline">\(T\)</span>是完全二叉树，则<span
class="math inline">\(T\)</span>具有如下性质：</p>
<ol type="1">
<li><span class="math inline">\(2h+1\le 2^{h+1}-1\)</span></li>
<li><span class="math inline">\(h+1\le n_E\le 2^h\)</span></li>
<li><span class="math inline">\(h\le n_I\le 2^h-1\)</span></li>
<li><span class="math inline">\(\log(n+1)-1\le h\le
\frac{(n-1)}{2}\)</span></li>
</ol>
<p>  完全二叉树中另有如下命题：</p>
<p>  在非空完全二叉树<span class="math inline">\(T\)</span>中，有<span
class="math inline">\(n_E\)</span>个外部节点和<span
class="math inline">\(n_I\)</span>个内部节点，则<span
class="math inline">\(n_E=n_I+1\)</span></p>
<h2 id="树的实现">树的实现</h2>
<h3 id="二叉树的链式存储结构">二叉树的链式存储结构</h3>
<p>  实现一个二叉树T的一个自然方法便是使用链式存储结构。一个节点包含多个引用：指向存储在位置p的元素的引用，指向p的孩子节点和双亲节点的引用。若p是T的根节点，则p的parent字段为None。同样，若p没有左子节点或右子节点，则相关字段即为None。树本身包含一个实例变量，存储指向根节点的引用，还包含一个size变量，表示T的所有节点数。在以下代码段中，我们给出一个二叉树的简单的实现。</p>
<blockquote>
<p>二叉树的初始化</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val:<span class="built_in">int</span></span>):</span><br><span class="line">        self.val: <span class="built_in">int</span> = val                 <span class="comment"># 节点值</span></span><br><span class="line">        self.left: TreeNode | <span class="literal">None</span> = <span class="literal">None</span>   <span class="comment"># 左子节点引用</span></span><br><span class="line">        self.right: TreeNode | <span class="literal">None</span> = <span class="literal">None</span>  <span class="comment"># 右子节点引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化二叉树</span></span><br><span class="line"><span class="comment"># 初始化节点</span></span><br><span class="line">n1 = TreeNode(val=<span class="number">1</span>)</span><br><span class="line">n2 = TreeNode(val=<span class="number">2</span>)</span><br><span class="line">n3 = TreeNode(val=<span class="number">3</span>)</span><br><span class="line">n4 = TreeNode(val=<span class="number">4</span>)</span><br><span class="line">n5 = TreeNode(val=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 构建节点之间的引用（指针）</span></span><br><span class="line">n1.left = n2</span><br><span class="line">n1.right = n3</span><br><span class="line">n2.left = n4</span><br><span class="line">n2.right = n5</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在二叉树中插入和删除节点</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插入与删除节点</span></span><br><span class="line">p = TreeNode(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 在 n1 -&gt; n2 中间插入节点 P</span></span><br><span class="line">n1.left = p</span><br><span class="line">p.left = n2</span><br><span class="line"><span class="comment"># 删除节点 P</span></span><br><span class="line">n1.left = n2</span><br></pre></td></tr></table></figure>
<p>  需要注意的是，插入节点可能会改变二叉树的原有逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除通常是由一套操作配合完成的，以实现有实际意义的操作。</p>
<h3 id="二叉树的遍历">二叉树的遍历</h3>
<p>  从物理结构的角度来看，树是一种基于链表的数据结构，因此其遍历方式是通过指针逐个访问节点。然而，树是一种非线性数据结构，这使得遍历树比遍历链表更加复杂，需要借助搜索算法来实现。</p>
<p>二叉树常见的遍历方式包括层序遍历、前序遍历、中序遍历、后序遍历等。</p>
<p>  <strong>层序遍历</strong></p>
<p>  如下图所示，<strong>层序遍历</strong>（level-order
traversal）从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。层序遍历本质上属于<strong>广度优先遍历</strong>（breadth-firth
traversal），也成<strong>广度优先搜索</strong>（breadth-first
search,BFS），它体现了一种“一圈一圈向外扩展”的逐层遍历方式。</p>
<p>  通常，我们使用一个队列来产生FIFO访问节点的顺序语义。整体的运行时间为<span
class="math inline">\(O(n)\)</span></p>
<figure>
<img
src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/binary_tree_bfs.png"
alt="二叉树的层序遍历" />
<figcaption aria-hidden="true">二叉树的层序遍历</figcaption>
</figure>
<blockquote>
<p>代码实现二叉树的层序遍历</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">level_order</span>(<span class="params">root: TreeNode | <span class="literal">None</span></span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;层序遍历&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化队列，加入根节点</span></span><br><span class="line">    queue: deque[TreeNode] = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="comment"># 初始化一个列表，用于保存遍历序列</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node: TreeNode = queue.popleft()  <span class="comment"># 队列出队</span></span><br><span class="line">        res.append(node.val)  <span class="comment"># 保存节点值</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            queue.append(node.left)  <span class="comment"># 左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            queue.append(node.right)  <span class="comment"># 右子节点入队</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>我们用一个例题来加深对BFS的理解：</p>
<blockquote>
<p>LeetCode 127.单词接龙 Hard</p>
</blockquote>
<p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列
是一个按下述规格形成的序列 beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt;
sk：</p>
<ul>
<li>每一对相邻的单词只差一个字母。</li>
<li>对于 1 &lt;= i &lt;= k 时，每个 si 都在 wordList 中。注意，
beginWord 不需要在 wordList 中。</li>
<li>sk == endWord</li>
</ul>
<p>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从
beginWord 到 endWord 的 最短转换序列 中的 单词数目
。如果不存在这样的转换序列，返回 0 。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong>beginWord = "hit", endWord = "cog", wordList =
["hot","dot","dog","lot","log","cog"]</p>
<p><strong>输出：</strong>5</p>
<p><strong>解释：</strong>一个最短转换序列是 "hit" -&gt; "hot" -&gt;
"dot" -&gt; "dog" -&gt; "cog", 返回它的长度 5。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong>beginWord = "hit", endWord = "cog", wordList =
["hot","dot","dog","lot","log"]</p>
<p><strong>输出：</strong>0</p>
<p><strong>解释：</strong>endWord "cog"
不在字典中，所以无法进行转换。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= beginWord.length &lt;= 10</li>
<li>endWord.length == beginWord.length</li>
<li>1 &lt;= wordList.length &lt;= 5000</li>
<li>wordList[i].length == beginWord.length</li>
<li>beginWord、endWord 和 wordList[i] 由小写英文字母组成</li>
<li>beginWord != endWord</li>
<li>wordList 中的所有字符串 互不相同</li>
</ul>
<p>   <strong>思路：</strong></p>
<p>  一种较为简单的思路是：我们考虑这样一个双向队列，队列中的元素是一个单词currentword和由它到达endword需要的最短步长steps构成的元组。我们可以执行简单的BFS算法，如下图所示：</p>
<p><img
src="https://pic.leetcode-cn.com/ec8f7e4f40134b932a9ff2e306d885e427bd8ee912801361849d92ddae6226f3-image.png" /></p>
<p>  我们从hit出发，此时hit所属的步长为1，接着我们搜索到了hot，此时hot所属步长为2，然后我们搜索到了dot和lot，为了避免出现重复循环地搜索，我们禁止搜索到已经出现过的单词，这种操作可以通过将搜索到的单词从字典中删除并转移到另一个列表中完成。通过不断地搜索，即可得到最后的答案。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ladderLength</span>(<span class="params">self, beginWord: <span class="built_in">str</span>, endWord: <span class="built_in">str</span>, wordList: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        queue = deque([(beginWord,<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            currentword,steps = queue.popleft() <span class="comment"># 弹出队列左端元素作为一次搜索的起点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> currentword == endWord:</span><br><span class="line">                <span class="keyword">return</span> steps</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(currentword)):</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>:</span><br><span class="line">                    nextword = currentword[:i] + c + currentword[i+<span class="number">1</span>:]  <span class="comment"># 遍历和当前单词差一个字母的所有单词，如果在wordlist中，就添加到队列中，同时从字典中删除，防止重复遍历</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> nextword <span class="keyword">in</span> wordList:</span><br><span class="line">                        queue.append((nextword,steps+<span class="number">1</span>))</span><br><span class="line">                        wordList.remove(nextword)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>  不幸的是，这种代码在逻辑上是可行的，但在效率上存在一些问题，我们可以采用双向BFS来提高我们的效率。</p>
<p>  <strong>思路二（双向BFS）：</strong></p>
<p>  我们不难看出，我们最初的想法是从beginword开始，通过发散式地搜索来找出所有的可能性，当数据量过大时，所需要的检索时间会进行指数级的膨胀。因此，我们可以考虑从beginword和endword两端同时开始检索，选取两个集合中较少的一个作为搜索的起点直到它的数量超过另一个。这样做的好处是，我们更好地控制了数据不断增长的速度，使得面对大数据量时依然保持不错的性能。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ladderLength</span>(<span class="params">self, beginWord: <span class="built_in">str</span>, endWord: <span class="built_in">str</span>, wordList: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        wordset = <span class="built_in">set</span>(wordList)</span><br><span class="line">        frontset = &#123;beginWord&#125;</span><br><span class="line">        backset = &#123;endWord&#125;</span><br><span class="line">        wordlen = <span class="built_in">len</span>(beginWord)</span><br><span class="line">        steps = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> frontset:</span><br><span class="line">            steps += <span class="number">1</span></span><br><span class="line">            newfrontset = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> frontset:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(wordlen):</span><br><span class="line">                    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>:</span><br><span class="line">                        nextword = word[:i] + c + word[i+<span class="number">1</span>:]</span><br><span class="line">                        <span class="keyword">if</span> nextword <span class="keyword">in</span> backset:</span><br><span class="line">                            <span class="keyword">return</span> steps</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> nextword <span class="keyword">in</span> wordset:</span><br><span class="line">                            newfrontset.add(nextword)</span><br><span class="line">                            wordset.remove(nextword)</span><br><span class="line"></span><br><span class="line">            frontset = newfrontset</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(backset) &lt; <span class="built_in">len</span>(frontset):</span><br><span class="line">                frontset,backset = backset,frontset</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>  <strong>深度优先搜索（DFS）</strong>：</p>
<p>  相应地，前序、中序和后序遍历都属于「<strong>深度优先遍历</strong>depth-first
traversal」，也称「<strong>深度优先搜索</strong> depth-first search,
DFS」，它体现了一种“先走到尽头，再回溯继续”的遍历方式。</p>
<p>  下图展示了对二叉树进行深度优先遍历的工作原理。其中前序遍历强调，我们需要先访问T的根，然后递归地访问子树的根。如果这棵树是有顺序的，则根据孩子的顺序遍历子树。后序遍历强调先访问子树的叶子节点，然后逐级向上进行访问。中序遍历强调“从左到右”非正式地访问T的节点。事实上，对于每个位置p，p将在其左子树之后及右子树之前被中序遍历访问。</p>
<figure>
<img
src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/binary_tree_dfs.png"
alt="二叉树的前序、中序、后序遍历" />
<figcaption aria-hidden="true">二叉树的前序、中序、后序遍历</figcaption>
</figure>
<blockquote>
<p>代码实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pre_order</span>(<span class="params">root: TreeNode | <span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;前序遍历&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span><br><span class="line">    res.append(root.val)</span><br><span class="line">    pre_order(root=root.left)</span><br><span class="line">    pre_order(root=root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">in_order</span>(<span class="params">root: TreeNode | <span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;中序遍历&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">    in_order(root=root.left)</span><br><span class="line">    res.append(root.val)</span><br><span class="line">    in_order(root=root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">post_order</span>(<span class="params">root: TreeNode | <span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;后序遍历&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span><br><span class="line">    post_order(root=root.left)</span><br><span class="line">    post_order(root=root.right)</span><br><span class="line">    res.append(root.val)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>深度优先搜索</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法：排序</title>
    <url>/posts/58ace847.html</url>
    <content><![CDATA[<h1 id="排序算法">排序算法</h1>
<p>  在本章中，我们将致力于研究针对对象集进行排序的算法。我们要对一个集合的元素进行重新排列，以使它们按照从小到大的顺序进行排列（或以此顺序生成一个新的副本）。Python中对数据排序提供了内在支持，包括对列表list类的sort方法，还有以排好的顺序生成一个包含任意元素集合的内置的sorted函数。这些内置函数使用了一些高级算法，并进行了高度的优化。我们很少有需要从头开始实现排序的特殊情况，但了解这些算法的底层逻辑和预期效率仍是有必要的。下面我们将逐个介绍。</p>
<span id="more"></span>
<p>在讨论各种排序算法之前，我们有必要了解我们应该从哪些方面来评价一个排序算法。</p>
<p><strong>运行效率：</strong>我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要。</p>
<p><strong>就地性：</strong>顾名思义，「原地排序」通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。</p>
<p><strong>稳定性：</strong>「稳定排序」在完成排序后，相等元素在数组中的相对顺序不发生改变。</p>
<p>稳定排序是多级排序场景的必要条件。假设我们有一个存储学生信息的表格，第
1 列和第 2
列分别是姓名和年龄。在这种情况下，「非稳定排序」可能导致输入数据的有序性丧失：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 输入数据是按照姓名排序好的</span></span><br><span class="line"><span class="meta"># (name, age)</span></span><br><span class="line">  (<span class="string">&#x27;A&#x27;</span>, <span class="number">19</span>)</span><br><span class="line">  (<span class="string">&#x27;B&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">  (<span class="string">&#x27;C&#x27;</span>, <span class="number">21</span>)</span><br><span class="line">  (<span class="string">&#x27;D&#x27;</span>, <span class="number">19</span>)</span><br><span class="line">  (<span class="string">&#x27;E&#x27;</span>, <span class="number">23</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 假设使用非稳定排序算法按年龄排序列表，</span></span><br><span class="line"><span class="meta"># 结果中 (<span class="string">&#x27;D&#x27;</span>, 19) 和 (<span class="string">&#x27;A&#x27;</span>, 19) 的相对位置改变，</span></span><br><span class="line"><span class="meta"># 输入数据按姓名排序的性质丢失</span></span><br><span class="line">  (<span class="string">&#x27;B&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">  (<span class="string">&#x27;D&#x27;</span>, <span class="number">19</span>)</span><br><span class="line">  (<span class="string">&#x27;A&#x27;</span>, <span class="number">19</span>)</span><br><span class="line">  (<span class="string">&#x27;C&#x27;</span>, <span class="number">21</span>)</span><br><span class="line">  (<span class="string">&#x27;E&#x27;</span>, <span class="number">23</span>)</span><br></pre></td></tr></table></figure>
<p><strong>自适应性：</strong>「自适应排序」的时间复杂度会受输入数据的影响，即最佳时间复杂度、最差时间复杂度、平均时间复杂度并不完全相等。</p>
<p>自适应性需要根据具体情况来评估。如果最差时间复杂度差于平均时间复杂度，说明排序算法在某些数据下性能可能劣化，因此被视为负面属性；而如果最佳时间复杂度优于平均时间复杂度，则被视为正面属性。</p>
<p><strong>是否基于比较：</strong>「基于比较的排序」依赖比较运算符（<span
class="math inline">\(&lt;、=、&gt;\)</span>）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为<span
class="math inline">\(O(n\log n)\)</span>
。而「非比较排序」不使用比较运算符，时间复杂度可达<span
class="math inline">\(O(n)\)</span> ，但其通用性相对较差。</p>
<h2 id="选择排序">选择排序</h2>
<p>  选择排序是一种简单直观的排序手段，它的工作原理是：开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。通过不断的交换操作，将第i小的元素放到数组编号为i的位置。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们用k来记录未排序区间内的最小元素</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;选择排序&#x27;&#x27;&#x27;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 内循环：找到未排序区间内的最小元素</span></span><br><span class="line">        k = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[k]:</span><br><span class="line">                k = j    <span class="comment"># 记录最小元素的索引</span></span><br><span class="line">        <span class="comment"># 将该最小元素与未排序区间的首个元素交换 </span></span><br><span class="line">        nums[i], nums[k] = nums[k], nums[i]</span><br></pre></td></tr></table></figure>
<p>  <strong>算法性质：</strong></p>
<p>时间复杂度为<span
class="math inline">\(O(n^2)\)</span>，空间复杂度为<span
class="math inline">\(O(1)\)</span>，非自适应性排序，原地排序，非稳定排序。</p>
<h2 id="冒泡排序">冒泡排序</h2>
<p>  冒泡排序是一种简单的排序方式，通过将相邻两个元素不断比较并交换完成整个序列的排序。由于在算法执行的过程中，较大的元素像是气泡般慢慢浮到数列的顶端，故叫冒泡排序。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;冒泡排序&#x27;&#x27;&#x27;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 外循环：未排序区间为[0, i]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 内循环：将未排序区间[0, i]中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nusm[j + <span class="number">1</span>]:</span><br><span class="line">                num[j], num[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://www.hello-algo.com/chapter_sorting/bubble_sort.assets/bubble_sort_overview.png"
alt="冒泡排序流程" />
<figcaption aria-hidden="true">冒泡排序流程</figcaption>
</figure>
<p>  <strong>优化：</strong>我们发现，如果某轮冒泡中没有执行任何交换操作，说明数组已经完成排序，可以直接返回结果。因此，可以增加一个标志位<code>flag</code>来监测这种情况，一旦出现就立即返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort_with_flag</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;冒泡排序（标志优化）&#x27;&#x27;&#x27;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 外循环：未排序区间为[0, i]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        flag = <span class="literal">False</span>    <span class="comment"># 初始化标志位</span></span><br><span class="line">        <span class="comment"># 内循环： 将未排序区间[0, i]中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j + <span class="number">1</span>]:</span><br><span class="line">                nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br><span class="line">                flag = <span class="literal">True</span>     <span class="comment"># 记录交换元素</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            <span class="keyword">break</span>    <span class="comment"># 此轮冒泡未交换任何元素，直接跳出</span></span><br></pre></td></tr></table></figure>
<p>  <strong>算法性质：</strong></p>
<p>时间复杂度为<span
class="math inline">\(O(n^2)\)</span>，自适应排序，在引入<code>flag</code>优化后，对已经排序的数组时间复杂度可达到<span
class="math inline">\(O(n)\)</span>。空间复杂度为<span
class="math inline">\(O(1)\)</span>、原地排序、稳定排序。</p>
<h2 id="插入排序">插入排序</h2>
<p>  插入排序同样是一种简单直观的排序算法。它的工作原理为将待排列元素划分为<strong>已排序</strong>和<strong>未排序</strong>两部分，每次从未排序的元素中选择一个插入到已排序的元素中的正确位置。生活中，我们通常在打扑克时使用插入排序，即从牌桌上抓一张牌，按牌面大小插到手牌后，再抓下一张牌。</p>
<figure>
<img
src="https://www.hello-algo.com/chapter_sorting/insertion_sort.assets/insertion_operation.png"
alt="单次插入操作" />
<figcaption aria-hidden="true">单次插入操作</figcaption>
</figure>
<figure>
<img
src="https://www.hello-algo.com/chapter_sorting/insertion_sort.assets/insertion_sort_overview.png"
alt="插入排序流程" />
<figcaption aria-hidden="true">插入排序流程</figcaption>
</figure>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;插入排序&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 外循环：已排序区间为[0, i-1]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">        base = nums[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 内循环：将base插入到已排序区间[0,i-1]中的正确位置</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[j] &gt; base:</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j]    <span class="comment"># 将nums[j]向右移动一位</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        nums[j + <span class="number">1</span>] = base    <span class="comment"># 将base赋值到正确位置</span></span><br></pre></td></tr></table></figure>
<p>  <strong>算法性质：</strong></p>
<p>时间复杂度<span
class="math inline">\(O(n^2)\)</span>、自适应排序、空间复杂度<span
class="math inline">\(O(1)\)</span>、原地排序、稳定排序</p>
<h2 id="快速排序">快速排序</h2>
<p>  快速排序是一种基于分治策略的排序算法，运行高效，应用广泛。</p>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>选择排序</tag>
        <tag>冒泡排序</tag>
        <tag>插入排序</tag>
        <tag>计数排序</tag>
        <tag>基数排序</tag>
        <tag>快速排序</tag>
        <tag>归并排序</tag>
        <tag>堆排序</tag>
        <tag>桶排序</tag>
        <tag>希尔排序</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法：回溯</title>
    <url>/posts/5c6a332.html</url>
    <content><![CDATA[<h1 id="回溯">回溯</h1>
<p><strong>什么是回溯</strong></p>
<p>通常来说，我们会这样介绍回溯算法：<strong>回溯法</strong>采用试错的思想，它尝试分步地解决一个问题。在分布解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效地正确的解答的时候，它将取消上一步甚至上几步的计算，再通过其他的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，它通过反复地重复上述的步骤来解决问题。回溯算法通常采用“深度优先搜索”来遍历解空间。在“二叉树”章节中，我们提到前序、中序和后序遍历都属于深度优先搜索。接下来，我们利用前序遍历构造一个回溯问题，逐步了解回溯算法的工作原理。</p>
<blockquote>
<p>给定一棵二叉树，搜索并记录所有值为7的节点，请返回节点列表。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pre_order</span>(<span class="params">root: TreeNode</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;前序遍历：例题一&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> root.val == <span class="number">7</span>:</span><br><span class="line">        <span class="comment"># 记录解</span></span><br><span class="line">        res.append(root)</span><br><span class="line">    pre_order(root.left)</span><br><span class="line">    pre_order(root.right)</span><br></pre></td></tr></table></figure>
<p><strong>尝试与回退</strong></p>
<p>之所以被称为回溯算法，是因为该算法在探索解空间时会采用“尝试”与“回退”的策略，通过撤销上一步的选择，退回到之前的状态，它得以访问其他的选择。</p>
<blockquote>
<p>在二叉树中搜索所有值为7的节点，请返回根节点到这些节点的路径</p>
</blockquote>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法, 深度优先搜索, 回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法竞赛中的树和图</title>
    <url>/posts/4daf3708.html</url>
    <content><![CDATA[<h1 id="从构建出发">从构建出发</h1>
<p>算法竞赛中，我们通常会遇到有关树形结构或图结构的问题，而如何有效地构建结构，利用好树和图的各种特点成为了解题的第一步。下文中我将给出恰当的方法来实现树和图中的基本操作。</p>
<blockquote>
<p><strong>例1：</strong> 给定一颗树，树根为<span
class="math inline">\(1\)</span>，每个点的点权为<span
class="math inline">\(V_i\)</span>，请实现这样的结构，使之可以遍历每个节点所在的深度，也可以遍历每个深度所有的节点</p>
<p><strong>输入格式：</strong> 输入的第一行包括一个整数<span
class="math inline">\(n\)</span>。</p>
<p>第二行包含<span class="math inline">\(n-1\)</span>个整数<span
class="math inline">\(F_i\)</span>，相邻整数间用一个空格分隔，分别表示第<span
class="math inline">\(2\)</span>至<span
class="math inline">\(n\)</span>个节点的父节点编号</p>
<p>第三行包含<span class="math inline">\(n\)</span>个整数<span
class="math inline">\(V_i\)</span>，相邻整数之间使用一个空格分隔，分别表示每个节点的点权</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">father = [<span class="number">0</span>, <span class="number">0</span>] + <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">values = [<span class="number">0</span>] + <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="comment"># 存每个节点的值</span></span><br><span class="line">dep = [<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="comment"># 每个节点的深度</span></span><br><span class="line">dep_node = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]   <span class="comment"># 存每个深度的节点</span></span><br><span class="line">deep_max = <span class="number">0</span>    <span class="comment"># 深度的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):   <span class="comment"># 求每个深度有哪些节点</span></span><br><span class="line">    dep[i] = dep[father[i]] + <span class="number">1</span> <span class="comment"># 一个节点的深度是它父节点深度 + 1得到的，这样我们就递归地得到了每个节点的深度</span></span><br><span class="line">    deep_max = <span class="built_in">max</span>(deep_max, dep[i])    <span class="comment"># 维护深度的最大值</span></span><br><span class="line">    dep_node[dep[i]].append(i)  <span class="comment"># i节点所在深度为dep[i],于是为dep_node的第dep[i]层添加i</span></span><br></pre></td></tr></table></figure>
<p>这样我们就得到了数组<span class="math inline">\(fathers\)</span>,
<span class="math inline">\(values\)</span>, <span
class="math inline">\(dep\)</span>, <span
class="math inline">\(dep\_node\)</span>和整数<span
class="math inline">\(deep\_max\)</span>,它们分别表示：</p>
<ul>
<li>编号为<span class="math inline">\(i\)</span>的节点的父节点<span
class="math inline">\(fathers[i]\)</span></li>
<li>编号为<span class="math inline">\(i\)</span>的节点的点权<span
class="math inline">\(values[i]\)</span></li>
<li>编号为<span class="math inline">\(i\)</span>的节点的深度<span
class="math inline">\(dep[i]\)</span></li>
<li>深度为<span class="math inline">\(i\)</span>的第<span
class="math inline">\(j\)</span>个节点<span
class="math inline">\(dep\_node[i][j]\)</span></li>
<li>树的最大深度<span class="math inline">\(deep\_max\)</span></li>
</ul>
<p>在得到这些基础属性后，我们就可以很方便地对树进行遍历等操作</p>
<p>在实际问题中，我们也会看到另一种树形结构的构筑，它的输入并没有直接告诉我们对于某个节点<span
class="math inline">\(i\)</span>，它的父节点是什么，而是类似图结构一样，告诉我们节点<span
class="math inline">\(u\)</span>和<span
class="math inline">\(v\)</span>之间存在一条边，对于这样的输入，我们可以用图的邻接表来构建恰当的树形结构。</p>
<blockquote>
<p>例2：给定一颗有<span
class="math inline">\(n\)</span>个节点的有根树，其中节点<span
class="math inline">\(i\)</span>的点权为<span
class="math inline">\(a_i\)</span>，请设计一种结构，使我们可以得到每个点对应的深度</p>
<p>输入格式：输入的第一行包含两个正整数<span
class="math inline">\(n,m\)</span>，用一个空格分隔。</p>
<p>第二行包含<span class="math inline">\(n\)</span>个整数<span
class="math inline">\(a_1,
a_2,...,a_n\)</span>,相邻整数之间使用一个空格分隔。</p>
<p>接下来<span
class="math inline">\(n-1\)</span>行，每行包含两个正整数<span
class="math inline">\(u_i,v_i\)</span>,表示节点<span
class="math inline">\(u_i\)</span>和<span
class="math inline">\(v_i\)</span>之间有一条边</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">values = [<span class="number">0</span>] + <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]  <span class="comment"># 用邻接表存储节点与边的信息</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">    u, v = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    g[u].append(v)</span><br><span class="line">    g[v].append(u)</span><br><span class="line"></span><br><span class="line">dep = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">dep[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">depth</span>(<span class="params">node, father</span>):</span><br><span class="line">    <span class="keyword">for</span> children <span class="keyword">in</span> g[node]:</span><br><span class="line">        <span class="keyword">if</span> children != father:</span><br><span class="line">            dep[children] = dep[node] + <span class="number">1</span></span><br><span class="line">            depth(children, node)   <span class="comment"># 递归地计算每个节点的深度</span></span><br><span class="line"></span><br><span class="line">depth(<span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>深度优先搜索</tag>
        <tag>树</tag>
        <tag>广度优先搜索</tag>
        <tag>图</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
</search>
